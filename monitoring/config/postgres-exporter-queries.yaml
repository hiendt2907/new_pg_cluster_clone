# ============================================================================
# PostgreSQL Exporter Custom Queries
# ============================================================================

# Replication lag (in seconds)
pg_replication_lag:
  query: |
    SELECT 
      application_name,
      client_addr,
      state,
      sync_state,
      COALESCE(EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())), 0) AS lag_seconds,
      COALESCE(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn), 0) AS lag_bytes
    FROM pg_stat_replication
    WHERE application_name != ''
  metrics:
    - application_name:
        usage: "LABEL"
        description: "Application name of the replica"
    - client_addr:
        usage: "LABEL"
        description: "IP address of the replica"
    - state:
        usage: "LABEL"
        description: "Replication state"
    - sync_state:
        usage: "LABEL"
        description: "Synchronization state"
    - lag_seconds:
        usage: "GAUGE"
        description: "Replication lag in seconds"
    - lag_bytes:
        usage: "GAUGE"
        description: "Replication lag in bytes"

# Replication slots
pg_replication_slots:
  query: |
    SELECT 
      slot_name,
      slot_type,
      database,
      active::int AS active,
      COALESCE(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn), 0) AS retained_bytes
    FROM pg_replication_slots
  metrics:
    - slot_name:
        usage: "LABEL"
        description: "Replication slot name"
    - slot_type:
        usage: "LABEL"
        description: "Type of replication slot"
    - database:
        usage: "LABEL"
        description: "Database name"
    - active:
        usage: "GAUGE"
        description: "Whether slot is active (1) or not (0)"
    - retained_bytes:
        usage: "GAUGE"
        description: "WAL bytes retained by this slot"

# Database size
pg_database_size:
  query: |
    SELECT 
      datname,
      pg_database_size(datname) AS size_bytes
    FROM pg_database
    WHERE datname NOT IN ('template0', 'template1')
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - size_bytes:
        usage: "GAUGE"
        description: "Database size in bytes"

# Table bloat
pg_table_bloat:
  query: |
    SELECT 
      schemaname,
      tablename AS relname,
      n_live_tup,
      n_dead_tup,
      CASE WHEN n_live_tup > 0 
        THEN (n_dead_tup::float / n_live_tup::float) 
        ELSE 0 
      END AS dead_tuple_ratio
    FROM pg_stat_user_tables
    WHERE n_dead_tup > 1000
    ORDER BY n_dead_tup DESC
    LIMIT 20
  metrics:
    - schemaname:
        usage: "LABEL"
        description: "Schema name"
    - relname:
        usage: "LABEL"
        description: "Table name"
    - n_live_tup:
        usage: "GAUGE"
        description: "Number of live tuples"
    - n_dead_tup:
        usage: "GAUGE"
        description: "Number of dead tuples"
    - dead_tuple_ratio:
        usage: "GAUGE"
        description: "Ratio of dead to live tuples"

# Long running queries
pg_long_running_queries:
  query: |
    SELECT 
      datname,
      usename,
      application_name,
      state,
      EXTRACT(EPOCH FROM (now() - query_start)) AS duration_seconds,
      EXTRACT(EPOCH FROM (now() - state_change)) AS state_duration_seconds,
      wait_event_type,
      wait_event
    FROM pg_stat_activity
    WHERE state != 'idle'
      AND query_start IS NOT NULL
      AND now() - query_start > interval '30 seconds'
    ORDER BY duration_seconds DESC
    LIMIT 10
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - usename:
        usage: "LABEL"
        description: "User name"
    - application_name:
        usage: "LABEL"
        description: "Application name"
    - state:
        usage: "LABEL"
        description: "Query state"
    - wait_event_type:
        usage: "LABEL"
        description: "Wait event type"
    - wait_event:
        usage: "LABEL"
        description: "Wait event"
    - duration_seconds:
        usage: "GAUGE"
        description: "Query duration in seconds"
    - state_duration_seconds:
        usage: "GAUGE"
        description: "Time in current state in seconds"

# Locks
pg_locks:
  query: |
    SELECT 
      datname,
      mode,
      granted::int AS granted,
      COUNT(*) AS lock_count
    FROM pg_locks
    LEFT JOIN pg_database ON pg_locks.database = pg_database.oid
    WHERE datname IS NOT NULL
    GROUP BY datname, mode, granted
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - mode:
        usage: "LABEL"
        description: "Lock mode"
    - granted:
        usage: "LABEL"
        description: "Whether lock is granted"
    - lock_count:
        usage: "GAUGE"
        description: "Number of locks"

# Blocking queries
pg_blocking_queries:
  query: |
    SELECT 
      blocked.datname,
      blocked.usename AS blocked_user,
      blocking.usename AS blocking_user,
      blocked.application_name AS blocked_app,
      blocking.application_name AS blocking_app,
      EXTRACT(EPOCH FROM (now() - blocked.query_start)) AS blocked_duration_seconds
    FROM pg_stat_activity blocked
    JOIN pg_locks blocked_locks ON blocked.pid = blocked_locks.pid
    JOIN pg_locks blocking_locks ON blocked_locks.locktype = blocking_locks.locktype
      AND blocked_locks.relation = blocking_locks.relation
      AND blocked_locks.pid != blocking_locks.pid
    JOIN pg_stat_activity blocking ON blocking_locks.pid = blocking.pid
    WHERE NOT blocked_locks.granted
      AND blocking_locks.granted
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - blocked_user:
        usage: "LABEL"
        description: "Blocked user"
    - blocking_user:
        usage: "LABEL"
        description: "Blocking user"
    - blocked_app:
        usage: "LABEL"
        description: "Blocked application"
    - blocking_app:
        usage: "LABEL"
        description: "Blocking application"
    - blocked_duration_seconds:
        usage: "GAUGE"
        description: "How long query has been blocked"

# Connection pool stats (from pgbouncer if present, else generic)
pg_connection_states:
  query: |
    SELECT 
      datname,
      state,
      COUNT(*) AS connection_count
    FROM pg_stat_activity
    GROUP BY datname, state
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - state:
        usage: "LABEL"
        description: "Connection state"
    - connection_count:
        usage: "GAUGE"
        description: "Number of connections in this state"

# Checkpoint statistics (PostgreSQL 17+)
pg_checkpoint_stats:
  query: |
    SELECT 
      num_timed AS checkpoints_timed,
      num_requested AS checkpoints_req,
      write_time AS checkpoint_write_time,
      sync_time AS checkpoint_sync_time,
      buffers_written AS buffers_checkpoint
    FROM pg_stat_checkpointer
  metrics:
    - checkpoints_timed:
        usage: "COUNTER"
        description: "Number of scheduled checkpoints"
    - checkpoints_req:
        usage: "COUNTER"
        description: "Number of requested checkpoints"
    - checkpoint_write_time:
        usage: "COUNTER"
        description: "Time spent writing checkpoints (ms)"
    - checkpoint_sync_time:
        usage: "COUNTER"
        description: "Time spent syncing checkpoints (ms)"
    - buffers_checkpoint:
        usage: "COUNTER"
        description: "Buffers written during checkpoints"
        description: "Buffers written by background writer"
    - buffers_backend:
        usage: "COUNTER"
        description: "Buffers written by backends"

# Cache hit ratio per database
pg_cache_hit_ratio:
  query: |
    SELECT 
      datname,
      CASE 
        WHEN (blks_hit + blks_read) = 0 THEN 1
        ELSE blks_hit::float / (blks_hit + blks_read)::float
      END AS cache_hit_ratio
    FROM pg_stat_database
    WHERE datname NOT IN ('template0', 'template1')
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - cache_hit_ratio:
        usage: "GAUGE"
        description: "Cache hit ratio (0-1)"

# Index usage
pg_index_usage:
  query: |
    SELECT 
      schemaname,
      tablename,
      indexname,
      idx_scan,
      idx_tup_read,
      idx_tup_fetch
    FROM pg_stat_user_indexes
    WHERE idx_scan = 0
      AND schemaname NOT IN ('pg_catalog', 'information_schema')
    ORDER BY pg_relation_size(indexrelid) DESC
    LIMIT 20
  metrics:
    - schemaname:
        usage: "LABEL"
        description: "Schema name"
    - tablename:
        usage: "LABEL"
        description: "Table name"
    - indexname:
        usage: "LABEL"
        description: "Index name"
    - idx_scan:
        usage: "COUNTER"
        description: "Number of index scans"
    - idx_tup_read:
        usage: "COUNTER"
        description: "Tuples read from index"
    - idx_tup_fetch:
        usage: "COUNTER"
        description: "Tuples fetched using index"

# Autovacuum activity
pg_autovacuum_activity:
  query: |
    SELECT 
      schemaname,
      tablename,
      last_vacuum,
      last_autovacuum,
      vacuum_count,
      autovacuum_count,
      EXTRACT(EPOCH FROM (now() - last_autovacuum)) AS seconds_since_last_autovacuum
    FROM pg_stat_user_tables
    WHERE autovacuum_count > 0
    ORDER BY last_autovacuum DESC NULLS LAST
    LIMIT 20
  metrics:
    - schemaname:
        usage: "LABEL"
        description: "Schema name"
    - tablename:
        usage: "LABEL"
        description: "Table name"
    - vacuum_count:
        usage: "COUNTER"
        description: "Number of manual vacuums"
    - autovacuum_count:
        usage: "COUNTER"
        description: "Number of autovacuums"
    - seconds_since_last_autovacuum:
        usage: "GAUGE"
        description: "Seconds since last autovacuum"

# Statement timeout violations (requires log parsing or extension)
pg_statement_timeouts:
  query: |
    SELECT 
      datname,
      COUNT(*) FILTER (WHERE wait_event_type = 'Timeout') AS timeout_count
    FROM pg_stat_activity
    WHERE state != 'idle'
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - timeout_count:
        usage: "GAUGE"
        description: "Number of queries in timeout state"

# Replica status (run on standby)
pg_replica_status:
  query: |
    SELECT 
      CASE 
        WHEN pg_is_in_recovery() THEN 1 
        ELSE 0 
      END AS is_replica,
      CASE 
        WHEN pg_is_in_recovery() 
        THEN EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp()))
        ELSE 0
      END AS replica_lag_seconds
  metrics:
    - is_replica:
        usage: "GAUGE"
        description: "Whether this instance is a replica (1) or primary (0)"
    - replica_lag_seconds:
        usage: "GAUGE"
        description: "Replication lag on this replica in seconds"

# Replication clients count
pg_replication_clients:
  query: |
    SELECT 
      COUNT(*) AS client_count,
      COUNT(*) FILTER (WHERE state = 'streaming') AS streaming_count,
      COUNT(*) FILTER (WHERE sync_state = 'sync') AS sync_count
    FROM pg_stat_replication
  metrics:
    - client_count:
        usage: "GAUGE"
        description: "Total number of replication clients"
    - streaming_count:
        usage: "GAUGE"
        description: "Number of clients in streaming state"
    - sync_count:
        usage: "GAUGE"
        description: "Number of synchronous replicas"
